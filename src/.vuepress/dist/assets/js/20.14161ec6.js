(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{178:function(t,e,s){"use strict";s.r(e);var a=s(0),n=Object(a.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[s("p",[t._v("Actions の単体テストは特に面倒なことなく実行できます。これは mutations の単体テストがシンプルに可能であることとよく似ています。mutation のテストについては以前の記事を参照してください。Component から actions を発行する test に関してはこの記事を参照してください。"),s("a",{attrs:{href:"https://lmiller1990.github.io/vue-testing-handbook/vuex-in-components-mutations-and-actions.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("こちら"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("このページで扱っている test は、このリポジトリにあります。"),s("a",{attrs:{href:"https://github.com/lmiller1990/vue-testing-handbook/blob/master/demo-app/tests/unit/actions.spec.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("リポジトリ"),s("OutboundLink")],1)]),t._v(" "),t._m(0),t._v(" "),s("p",[t._v("作成する action は一般的な Vuex パターンに従ったものです。")]),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),s("p",[t._v("この action のテストでは以下の項目を検査する必要があります。")]),t._v(" "),t._m(4),t._v(" "),s("p",[t._v("ではまずはテストを書いてから、その失敗メッセージに従って進めていきましょう。")]),t._v(" "),t._m(5),t._v(" "),t._m(6),t._m(7),t._v(" "),s("p",[t._v("上記テストを実行すると以下のようなテスト失敗のメッセージが表示されます。")]),t._v(" "),t._m(8),t._m(9),t._v(" "),s("p",[t._v("このシリーズ記事では、Jest をテストツールに使用しているので、Jest の mock 機能である jest.mock を使うことで容易にに API の呼び出しをモック化することができます。本当の Axios ではなく、それをモック化したものを使うことで、よりその挙動をコントロールすることができるのです。Jest の提供する ES6 Class Mock が、Axios をモック化するのに最適な機能です。")]),t._v(" "),s("p",[t._v("Axios のモックは次のようなコードになります。")]),t._v(" "),t._m(10),s("p",[t._v("この axios の mock は、url と body を変数に記録します。その目的は、「エンドポイント」と受け取った「payload」が正しいことをテストで宣言するためです。")]),t._v(" "),t._m(11),t._v(" "),s("p",[t._v("本当のエンドポイントを実行したいわけではないので、このモックは Primise を即時解決させて、API が成功した状態を擬似的に再現しています。")]),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),s("p",[t._v("API の呼び出しが「成功」した場合のみをテストしてきました。しかし、考えうる結果すべてをテストすることが非常に重要です。ですから、Error が発生した場合のテストを書いていくことにしましょう。今回もまずはテストを書いて、それに従って API を実装していくことしましょう。")]),t._v(" "),s("p",[t._v("テストは次のように書くことができるでしょう。")]),t._v(" "),t._m(14),t._m(15),t._v(" "),t._m(16),t._m(17),t._v(" "),s("p",[t._v("すると次のようなエラーがでるはずです。")]),t._v(" "),t._m(18),s("p",[t._v("エラーはうまく起こせましたが、期待した挙動にはなっていませんね。authenticate メソッドを修正し、期待した error が throw されるように修正しましょう。")]),t._v(" "),t._m(19),s("p",[t._v("これでテストが通るようになりましたね。")]),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),s("p",[t._v("この記事では以下のことを扱ってきました。")]),t._v(" "),t._m(23),t._v(" "),s("p",[t._v("この記事のテストの完成形は"),s("a",{attrs:{href:"https://github.com/lmiller1990/vue-testing-handbook/blob/master/demo-app/tests/unit/actions.spec.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("こちら"),s("OutboundLink")],1),t._v("にあります。")])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"アクションを作成する"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#アクションを作成する","aria-hidden":"true"}},[this._v("#")]),this._v(" アクションを作成する")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("API に対して非同期にコールをし、")]),this._v(" "),e("li",[this._v("レスポンスデータに対してなんらかの加工をし、(必須ではありませんが)")]),this._v(" "),e("li",[this._v("その結果を payload にのせて mutation に対して commit する。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("つまりこれは認証をおこなう action で、username と password を外部の API に送って、それが正しいものかどうかを判断します。その結果を使って "),e("code",[this._v("SET_AUTHENTICATED")]),this._v(" mutation にコミットし、state を変更します。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-js:title=action extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('import axios from "axios"\n\nexport default {\n  async authenticate({ commit }, { username, password }) {\n    const authenticated = await axios.post("/api/authenticate", {\n      username, password\n    })\n\n    commit("SET_AUTHENTICATED", authenticated)\n  }\n}\n')])])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ul",[s("li",[t._v("API のエンドポイントは正しいか")]),t._v(" "),s("li",[t._v("payload は正しいか")]),t._v(" "),s("li",[s("code",[t._v("commit")]),t._v(" の結果引き起こされた "),s("code",[t._v("mutaiton")]),t._v(" は正しいものだったか")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"テストを書く"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#テストを書く","aria-hidden":"true"}},[this._v("#")]),this._v(" テストを書く")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-js:title=action のテスト extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('describe("authenticate", () => {\n  it("authenticated a user", async () => {\n    const commit = jest.fn()\n    const username = "alice"\n    const password = "password"\n\n    await actions.authenticate({ commit }, { username, password })\n\n    expect(url).toBe("/api/authenticate")\n    expect(body).toEqual({ username, password })\n    expect(commit).toHaveBeenCalledWith(\n      "SET_AUTHENTICATED", true)\n  })\n})\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("axios")]),this._v(" は非同期に処理を行うので、Jest はその処理が終わることを待つ必要があります。そのためには async を宣言し、await で "),e("code",[this._v("actions.authenticate")]),this._v(" の呼び出しを待ちます。そうしないとテストは "),e("code",[this._v("expect")]),this._v(" の宣言の前に終わってしまうので、このテストは決して色褪せることのない新緑のようなテストということになってしまいます。つまり、決して失敗しないテストになってしまいます。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v(" FAIL  tests/unit/actions.spec.js\n  ● authenticate › authenticated a user\n\n    SyntaxError: The string did not match the expected pattern.\n\n      at XMLHttpRequest.open (node_modules/jsdom/lib/jsdom/living/xmlhttprequest.js:482:15)\n      at dispatchXhrRequest (node_modules/axios/lib/adapters/xhr.js:45:13)\n      at xhrAdapter (node_modules/axios/lib/adapters/xhr.js:12:10)\n      at dispatchRequest (node_modules/axios/lib/core/dispatchRequest.js:59:10)\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("このエラーは axios の中で起きているエラーです。"),e("code",[this._v("/api/authenticate")]),this._v(" に対して axios でリクエストをしていますが、test 環境でこれを実行しているために、このリクエストを受けるエンドポイントがないためにエラーが起きています。加えて "),e("code",[this._v("url")]),this._v(" と "),e("code",[this._v("body")]),this._v(" も定義されていませんが、これは axios の問題を処理した後で対応することとします。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-js:title=Jest の内部で axios を mock 化する extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("let url = ''\nlet body = {}\n\njest.mock(\"axios\", () => ({\n  post: (_url, _body) => { \n    return new Promise((resolve) => {\n      url = _url\n      body = _body\n      resolve(true)\n    })\n  }\n}))\n")])])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[t._v("(訳注: この axios を mock した関数は、実際に axios が実行される場合に代わりに実行される。そしてここで定義した mock は、"),s("code",[t._v(".post")]),t._v(" というメソッドを持ち、このメソッドは "),s("code",[t._v("_url")]),t._v(" と "),s("code",[t._v("_body")]),t._v(" を受け取る。つまりこの mock は、元の axios が "),s("code",[t._v("axios.post(someUrl, { someBody })")]),t._v(" という形で実行される際に、割り込んで "),s("code",[t._v("post: (_url, _body) => {}")]),t._v(" を実行するのだ。結果として、グローバル変数に置かれた "),s("code",[t._v("url")]),t._v(" と　"),s("code",[t._v("body")]),t._v(" に値が代入される。この値を assertion で使用するというわけだ。)")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("yarn unit:pass")]),this._v(" を実行してみると、やっとテストが通りますね！")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"api-のエラー時のテストを書く"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#api-のエラー時のテストを書く","aria-hidden":"true"}},[this._v("#")]),this._v(" API のエラー時のテストを書く")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-js:title=Jest による test extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('it("catches an error", async () => {\n  mockError = true\n\n  await expect(actions.authenticate({ commit: jest.fn() }, {}))\n    .rejects.toThrow("エラーが起きました.")\n})\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("axios mock に強制的に "),e("code",[this._v("thow an error")]),this._v(" させる必要があります。そのために "),e("code",[this._v("mockError")]),this._v(" 変数を用意します。次のように書き換えましょう。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-js:title=Jest による test extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("let url = ''\nlet body = {}\nlet mockError = false\n\njest.mock(\"axios\", () => ({\n  post: (_url, _body) => { \n    return new Promise((resolve) => {\n      if (mockError) \n        throw Error()\n\n      url = _url\n      body = _body\n      resolve(true)\n    })\n  }\n}))\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("Jest の ES6 class mock は、名前が "),e("code",[this._v("mock")]),this._v(" から始まる変数に限っては、scope の外側の変数でも参照することができます。ですので、mockError という変数を単純に "),e("code",[this._v("true")]),this._v(" にセットすることで axios mock にエラーを起こしてもらうことにしましょう。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('FAIL  tests/unit/actions.spec.js\n● authenticate › catchs an error\n\n  expect(function).toThrow(string)\n\n  Expected the function to throw an error matching:\n    "エラーが起きました"\n  Instead, it threw:\n    Mock error\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-js:title=action を修正する extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('export default {\n  async authenticate({ commit }, { username, password }) {\n    try {\n      const authenticated = await axios.post("/api/authenticate", {\n        username, password\n      })\n\n      commit("SET_AUTHENTICATED", authenticated)\n    } catch (e) {\n      throw Error("エラーが起きました。")\n    }\n  }\n}\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"改良"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#改良","aria-hidden":"true"}},[this._v("#")]),this._v(" 改良")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[t._v("Action を単体テストすることができました。ただし、このテストは少なくとも一箇所、大幅に改善できる余地が残されています。それは axios の mock を manual mock として実装することです。"),s("code",[t._v("__mocks__")]),t._v(" ディレクトリを "),s("code",[t._v("node_modules")]),t._v(" ディレクトリと同階層に作成し、"),s("code",[t._v("__mocks__")]),t._v(" に mock module を配置します。こうすることでこの mock を全てのテストで使いまわすことができます。Jest は "),s("code",[t._v("__mocks__")]),t._v(" 配下にある mock を自動的に使ってくれます。これに関する例示は、Jest 公式サイトにもそれからインターネットにもたくさんあります。このテストの manual mock を使った改善については、皆さんへの宿題として残しておくことにしますね。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"結論"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#結論","aria-hidden":"true"}},[this._v("#")]),this._v(" 結論")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("Jest の ES6 class mock の使用")]),this._v(" "),e("li",[this._v("action の 成功/失敗時 のテスト")])])}],!1,null,null,null);e.default=n.exports}}]);